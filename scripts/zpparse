#!/usr/bin/env python2

import sys, os, string
import urllib
from lxml import etree
from zpbuild_globals import build_targets, python_targets, zpconf, zpdefs, reldefs, builddefs
import codecs
import json

zp_json = None
rel_json = None
zp_pydict = {}
rel_pydict = {}

def updateZpDefs(url="http://wiki.zenoss.org/Special:Ask/-5B-5BCategory:ZenPacks-5D-5D/-3FZenPack-20name/-3FSource-20URI/-3FDescription/format%3Djson/limit%3D99999/offset%3D0"):
	# Update ZenPack definition JSON file from wiki, update our internal xmlroot variable with new data as well.
	req = urllib.urlopen(url)
	encoding=req.headers['content-type'].split('charset=')[-1]
	ucontent=unicode(req.read(),encoding)
	l = open(zpdefs, 'w')
	l.write(ucontent.encode('utf-8'))
	req.close()
	l.close()

def updateRelDefs(url="http://wiki.zenoss.org/Special:Ask/-5B-5BRelease-20of::%2B-5D-5D/-3FRelease-20of%3DZenPack/-3FVersion/-3FTag/-3FCompatible-20with/-3FRequires/format%3Djson/limit%3D99999/mainlabel%3D-2D/offset%3D0"):
	# Update ZenPack definition JSON file from wiki, update our internal xmlroot variable with new data as well.
	req = urllib.urlopen(url)
	encoding=req.headers['content-type'].split('charset=')[-1]
	ucontent=unicode(req.read(),encoding)
	l = open(reldefs, 'w')
	l.write(ucontent.encode('utf-8'))
	req.close()
	l.close()

def readDefs():
	global zp_json, rel_json
	l = codecs.open(zpdefs, 'r', 'utf-8')
	zp_json = json.load(l)
	l.close()
	l = codecs.open(reldefs, 'r', 'utf-8')
	rel_json = json.load(l)
	l.close()

def parseDefs():
	global zp_json, rel_json, zp_pydict, rel_pydict
	for key in zp_json["results"]:
		zp_pydict[key] ={}
		for elkey in zp_json["results"][key]["printouts"]:
			val = zp_json["results"][key]["printouts"][elkey]
			if len(val):
				zp_pydict[key][elkey] = val[0]
			else:
				zp_pydict[key][elkey] = None
	for key in rel_json["results"]:
		outkey = rel_json["results"][key]["printouts"]["ZenPack"][0]["fulltext"]
		if not outkey in rel_pydict:
			rel_pydict[outkey] = {} 
		stuff = {}
		tag = rel_json["results"][key]["printouts"]["Tag"]
		if len(tag):
			stuff["Tag"] = tag[0]
		stuff["Compatible with"] = rel_json["results"][key]["printouts"]["Compatible with"]
		rel_pydict[outkey][rel_json["results"][key]["printouts"]["Version"][0]] = stuff

def vercmp(v1,v2):
	v1s = v1.split(".")
	v2s = v2.split(".")
	while len(v1s) < 3:
		v1s.append("0")
	while len(v2s) < 3:
		v2s.append("0")
	pos = 0
	while pos < 3:
		x = int(v1s[pos]) - int(v2s[pos])
		if x == 0:
			pos += 1
			continue
		else:
			return x
	return 0

# INITIAL GLOBAL VARIABLE DEFINITIONS:

if __name__ == "__main__":
	sys.stderr.write("Updating JSON ZenPack definitions...\n")
	updateZpDefs()
	updateRelDefs()
	sys.stderr.write("Done.\n")

readDefs()
parseDefs()
build_set = set()
aux_data = {}
for full_zpname in zp_pydict:
	if full_zpname not in rel_pydict:
		continue
	releases = rel_pydict[full_zpname]
	zpinfo = zp_pydict[full_zpname]
	sorted_relkeys = releases.keys()
	sorted_relkeys.sort(cmp=vercmp)

	# determine which releases that are compatible with each target version of Zenoss:

	targets = {}
	for zenoss_prod_name in build_targets:
		targets[zenoss_prod_name] = []
	target_versions = targets.keys()
	for version in sorted_relkeys:
		# start from oldest version...
		for zenoss_prod_name in target_versions:
			if zenoss_prod_name in releases[version]["Compatible with"]:
				# record that "Zenoss Core 4.2.x" should build release version "r" ("1.0", for example)
				targets[zenoss_prod_name].append(version)

	# Now, we will create a build set. A build set consists of a tuple containing the release version, the target
	# python version, and the name of the ZenPack. This tuple represents a uniquely-identifiable build that will
	# be performed.

	# We will also add some additional build-related data to the aux_data dictionary, indexed by ZenPack name.
	# This information is necessary for building, but is not unique to each
	for zenoss_prod_name in target_versions:
		for version in targets[zenoss_prod_name]:
			if "Tag" in releases[version]:
				tag = releases[version]["Tag"]
			else:
				tag = None
			tup = (full_zpname, version, python_targets[zenoss_prod_name])
			# use the uniqueness of the build tuple to avoid adding duplicate builds to our build set:
			if tup not in build_set:
				aud = { "zpname": zpinfo["ZenPack name"], "tag" : tag, "src_uri": zpinfo["Source URI"] }
				aux_data[full_zpname] = aud
				build_set.add(tup)
# Now that we have all our unique builds in build_set and aux_data, output XML describing what to do.
# I am designing this to output XML so another build tool can take care of building, and all the parsing
# stuff is decoupled from the build engine.

xml_root = etree.Element("builds")
for build in build_set:
	title, version, python_version = build
	aud = aux_data[title]
	xml_child = etree.Element("build")
	xml_title = etree.SubElement(xml_child, "title")
	xml_title.text = title
	xml_version = etree.SubElement(xml_child, "version")
	xml_version.text = version
	xml_pyver = etree.SubElement(xml_child,"python_version")
	xml_pyver.text = python_version
	xml_zpname = etree.SubElement(xml_child,"zenpack_name")
	xml_zpname.text = aud["zpname"]
	if "tag" in aud and aud["tag"] != None:
		xml_tag = etree.SubElement(xml_child,"tag")
		xml_tag.text = aud["tag"]
	else:
		continue
	if "src_uri" in aud and aud["src_uri"] != None:
		xml_src_uri = etree.SubElement(xml_child,"src_uri")
		xml_src_uri.text = aud["src_uri"]
	else:
		continue
	xml_root.append(xml_child)
a = open(builddefs,'w')
a.write(etree.tostring(xml_root, pretty_print=True))
a.close()
