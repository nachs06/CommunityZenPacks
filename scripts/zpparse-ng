#!/usr/bin/env python2

import sys, os, string
import urllib
from lxml import etree
from zpbuild_globals_ng import build_targets, python_targets, zpconf, zpdef_file, reldef_file, builddefs
import codecs
import json

zp_json = None
rel_json = None
zp_pydict = {}
rel_pydict = {}

zpdef_url="http://wiki.zenoss.org/Special:Ask/-5B-5BCategory:ZenPacks-5D-5D-20-5B-5BFlavor::free-5D-5D/-3F-23-2D/-3FOrganization/-3FAuthor/-3FMaintainer/-3FSummary/-3FCategories/-3FSource-20URI/-3FLicense/format%3Djson/offset%3D0"

reldef_url="http://wiki.zenoss.org/Special:Ask/-5B-5BRelease-20of::%2B-5D-5D/-3FRelease-20of%3DZenPack/-3FVersion/-3FTag/-3FCompatible-20with/-3FIncompatible-20with/--3FRequires/format%3Djson/limit%3D99999/mainlabel%3D-2D/offset%3D0"

def updateDefs(url, outfile):
	""" given a URL, read JSON and write it out to a file on disk."""
	# Update ZenPack definition JSON file from wiki, update our internal xmlroot variable with new data as well.
	req = urllib.urlopen(url)
	encoding=req.headers['content-type'].split('charset=')[-1]
	ucontent=unicode(req.read(),encoding)
	l = open(outfile, 'w')
	l.write(ucontent.encode('utf-8'))
	req.close()
	l.close()

def parseDefs(json_fn, altkey=None):
	"""Given a filename, read JSON in, and parse it from Semantic Mediawiki output format into a much simpler nested dictionary format.
	
	Optional value alkey allows you to specify a property name to use to source the key rather than the default.
	"""
	l = codecs.open(json_fn, 'r', 'utf-8')
	my_json = json.load(l)
	l.close()
	simple_dict = {}
	# key will be the name of each object exported in the JSON:
	for key in my_json["results"]:
		# props will store all the property key/value pairs for the object we are processing:
		props = {}
		# elkey contains the property key name:
		for elkey in my_json["results"][key]["printouts"]:
			# blob can be a list of dicts, or strings. Handle carefully to get property values: 
			blob = my_json["results"][key]["printouts"][elkey]
			# update our simple dictionary with the property and value, or None
			# outval will be the value we write to simple_dict[key][elkey]:
			if not len(blob):
				# blob is empty, property value was not defined:
				outval = None
			elif type(blob[0]) == type({}):
				# blob contains dicts, grab "fulltext" from each dict, add to list:
				outval = []
				for d in blob:
					outval.append(d["fulltext"])
			else:
				# we will assume that we have strings or numbers, so just append them directly:
				outval = blob
			# if things are in lists, but only have one item, remove the outer list. Otherwise preserve it:
			# (This happens when we have multi-select, like when you can specify multiple authors, but specify only one...)
			if type(outval) == type([]) and len(outval) == 1:
				outval = outval[0]
			props[elkey] = outval
		if altkey and altkey in props:
			# alternate key specified. Grab from the property:
			key = props[altkey]
			if type(key) == type([]):
				# have a list -- so grab the first item to be the key
				key = key[0]
			# now delete original property:
			del props[altkey]
		simple_dict[key] = props
	# the output format is simple_dict["MyObject"]["myproperty"] = myvalue.
	# myvalue can be None, if not specified, a single value, like a string, or a list of things, like a list of strings, if multiple values were specified.
	return simple_dict

if __name__ == "__main__":
	#sys.stderr.write("Updating JSON ZenPack definitions...\n")
	updateDefs(zpdef_url, zpdef_file)
	zpdefs = parseDefs(zpdef_file)
	updateDefs(reldef_url, reldef_file)
	reldefs = parseDefs(reldef_file, altkey="ZenPack")
	print zpdefs, reldefs
	#sys.stderr.write("Done.\n")

