#!/usr/bin/env python2

import sys, os, string
import urllib
from lxml import etree

build_targets = {
	"Zenoss Core 3.2.x" : None,
	"Zenoss Resource Manager 4.1.x" : None,
	"Zenoss Core 4.2.x" : None 
}

python_targets = {
	"Zenoss Core 3.2.x" : "2.6",
	"Zenoss Resource Manager 4.1.x" : "2.7",
	"Zenoss Core 4.2.x" : "2.7"
}

def updateZpDefs(url="http://wiki.zenoss.org/Special:ViewXML?title=Special%3AViewXML&namespaces%5B500%5D=on&simplified_format=on"):
	# Update ZenPack definition XML file from wiki, update our internal xmlroot variable with new data as well.
	global xmlroot
	a = urllib.urlopen(url)
	l = open(os.path.join(zpconf, "zpdefs.xml"), 'w')
	i = a.read()
	xmlroot = etree.fromstring(i)
	l.write(i)
	a.close()
	l.close()

def readZpDefs():
	# Read in existing XML definition file on disk, use it to generate internal xmlroot variable.
	global xmlroot
	l = open(os.path.join(zpconf, "zpdefs.xml"), 'r')
	xmlroot = etree.parse(l)
	l.close()

def vercmp(v1,v2):
	v1s = v1.split(".")
	v2s = v2.split(".")
	while len(v1s) < 3:
		v1s.append("0")
	while len(v2s) < 3:
		v2s.append("0")
	pos = 0
	while pos < 3:
		x = int(v1s[pos]) - int(v2s[pos])
		if x == 0:
			pos += 1
			continue
		else:
			return x
	return 0

# INITIAL GLOBAL VARIABLE DEFINITIONS:

xmlroot = None

def setup():
	# initialize directories:
	global zphome, zpconf, zpdefs
	a = os.getenv("ZENHOME")
	# try to use ZENHOME/etc to store zpdefs.xml; otherwise fall back to /var/tmp/zbuild/etc:
	if a != None:
		zphome=a
	else:
		zphome="/var/tmp/zpbuild"
	zpconf=zphome + "/etc"
	zpdefs=zpconf + "/zpdefs.xml"
	if not os.path.exists(zpconf):
		print("Warning: %s does not exist -- creating..." % zpconf)
		os.makedirs(zpconf)

if __name__ == "__main__":
	setup()
	if not os.path.exists(zpconf) or ( len(sys.argv) == 2 and sys.argv[1] == "sync"):
		print "Updating XML ZenPack definitions..."
		updateZpDefs()
		print "Done."
		sys.exit(0)
	else:
		readZpDefs()
build_set = set()
aux_data = {}
for e in xmlroot.iter("Page"):
	zenpack = e.xpath("ZenPack")
	if len(zenpack) == 0:
		# likely a redirect
		continue
	else:
		zenpack = zenpack[0]
	title = e.xpath("Title")[0].text
	homepage = zenpack.xpath("Homepage")
	if len(homepage):
		homepage = homepage[0].text
	else:
		homepage = None
	zpname = zenpack.xpath("ZenPack_name")[0].text
	src_uri = zenpack.xpath("Source_URI")
	if len(src_uri):
		src_uri = src_uri[0].text
	else:
		src_uri = None
	#print title, "(%s)" % zpname,  src_uri
	releases = {} 
	for r in e.xpath("Release"):
		out = {}
		version = r.xpath("Version")[0].text
		compat = r.xpath("Compatible_with")[0].text.split(",")
		out["compat"] = []
		for x in compat:
			x = x.strip()
			if len(x):
				out["compat"].append(x)
		try:
			out["tag"] = r.xpath("Tag")[0].text
		except:
			pass
		releases[version] = out
	sorted_relkeys = releases.keys()
	sorted_relkeys.sort(cmp=vercmp)

	# we want to build the most recent release that is compatible with each of our build targets.
	# This may end up being one version of the ZenPack, or multiple versions.

	targets = build_targets.copy()
	target_versions = targets.keys()
	for r in sorted_relkeys:
		# start from oldest version...
		for t in target_versions:
			if t in releases[r]["compat"]:
				# record that "Zenoss Core 4.2.x" should build release version "r" ("1.0", for example)
				targets[t] = r
		# keep iterating thru newer versions to see if we have a newer release that will work on each version:

	# Now, we will create a build set. A build set consists of a tuple containing the release version, the target
	# python version, and the name of the ZenPack. This tuple represents a uniquely-identifiable build that will
	# be performed.

	# We will also add some additional build-related data to the aux_data dictionary, indexed by ZenPack name.
	# This information is necessary for building, but is not unique to each

	for t in target_versions:
		if targets[t] == None:
			# no build for this version of Zenoss:
			continue
		version = targets[t]
		if "tag" in releases[version]:
			tag = releases[version]["tag"]
		else:
			tag = None
		tup = (title, version, python_targets[t])
		# use the uniqueness of the build tuple to avoid adding duplicate builds to our build set:
		if tup not in build_set:
			aud = { "zpname": zpname, "tag" : tag, "src_uri": src_uri }
			aux_data[title] = aud
			build_set.add(tup)
	
# Now that we have all our unique builds in build_set and aux_data, output XML describing what to do.
# I am designing this to output XML so another build tool can take care of building, and all the parsing
# stuff is decoupled from the build engine.

xml_root = etree.Element("builds")
for build in build_set:
	title, version, python_version = build
	aud = aux_data[title]
	xml_child = etree.SubElement(xml_root, "build")	
	xml_title = etree.SubElement(xml_child, "title")
	xml_title.text = title
	xml_version = etree.SubElement(xml_child, "version")
	xml_version.text = version
	xml_pyver = etree.SubElement(xml_child,"python_version")
	xml_pyver.text = python_version
	xml_zpname = etree.SubElement(xml_child,"zenpack_name")
	xml_zpname.text = aud["zpname"]
	if "tag" in aud and aud["tag"] != None:
		xml_tag = etree.SubElement(xml_child,"tag")
		xml_tag.text = aud["tag"]
	if "src_uri" in aud and aud["src_uri"] != None:
		xml_src_uri = etree.SubElement(xml_child,"src_uri")
		xml_src_uri.text = aud["src_uri"]
print etree.tostring(xml_root, pretty_print=True)
